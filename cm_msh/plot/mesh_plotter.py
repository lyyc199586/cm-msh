"""
mesh_plotter.py

This module provides functionality to visualize 2D GMSH meshes using matplotlib.
It supports coloring by physical groups, displaying node and element IDs, and highlighting named boundaries.

Author: Yangyuanchen Liu
Date: 2025-05-19
"""

from pathlib import Path
from collections import defaultdict
import numpy as np
import meshio
import matplotlib.pyplot as plt
import matplotlib.cm as cm
import matplotlib.colors as mcolors
import random


class MeshPlotter:
    """
    A class to handle the visualization of 2D meshes generated by GMSH.

    Attributes:
        msh_path (Path): Path to the mesh file.
        mesh (meshio.Mesh): The mesh object loaded from the file.
    """

    def __init__(self, msh_path: Path):
        """
        Initializes the MeshPlotter with the given mesh file path.

        Args:
            msh_path (Path): Path to the mesh file to be visualized.
        """
        self.msh_path = Path(msh_path)
        self.mesh = meshio.read(self.msh_path)

    def plot(
        self,
        show_node_ids: bool = False,
        show_element_ids: bool = False,
        color_by_physical_group: bool = True,
        show_boundaries: bool = True,
        legend: bool = True,
        save_path: Path = None,
        ax: plt.Axes = None,
    ) -> plt.Axes:
        """
        Plots the 2D mesh with optional annotations and physical group coloring.

        Args:
            show_node_ids (bool): Whether to display node IDs. Defaults to False.
            show_element_ids (bool): Whether to display element IDs. Defaults to False.
            color_by_physical_group (bool): Whether to color elements by their physical group. Defaults to True.
            show_boundaries (bool): Whether to highlight and label 1D physical boundaries. Defaults to True.
            legend (bool): Whether to show a legend for physical group names. Defaults to True.
            save_path (Path, optional): If provided, saves the figure to this path. Defaults to None.
            ax (plt.Axes, optional): Axes to draw on. If None, a new figure is created.

        Returns:
            plt.Axes: The matplotlib Axes object containing the plot.
        """
        if ax is None:
            fig, ax = plt.subplots(figsize=(8, 8))

        points = self.mesh.points[:, :2]
        cell_data = self.mesh.cell_data_dict.get("gmsh:physical", {})
        field_data = self.mesh.field_data or {}

        # Map physical tag → name
        tag_to_name = {val[1]: key for key, val in field_data.items()}

        cmap = cm.get_cmap("tab20", 256)
        grouped_cells = defaultdict(list)

        # Group all relevant elements by physical tag
        for block, phys_tags in zip(self.mesh.cells, self.mesh.cell_data.get("gmsh:physical", [])):
            if block.type not in ["triangle", "quad"]:
                continue
            for conn, tag in zip(block.data, phys_tags):
                grouped_cells[tag].append(conn)

        tag_list = sorted(grouped_cells.keys())

        # Assign colors — shuffled to reduce adjacent duplication
        color_indices = list(range(len(tag_list)))
        random.seed(0)
        random.shuffle(color_indices)
        color_map = {
            tag: cmap(i / len(tag_list))
            for tag, i in zip(tag_list, color_indices)
        }

        # Draw 2D elements
        for tag, conn_list in grouped_cells.items():
            face_color = color_map[tag]
            for i, conn in enumerate(conn_list):
                polygon = points[conn]
                ax.fill(*zip(*polygon), facecolor=face_color, edgecolor="black", linewidth=0.3, alpha=0.8)
                if show_element_ids:
                    cx, cy = np.mean(polygon, axis=0)
                    ax.text(cx, cy, str(i), fontsize=6, color="blue")

        # Draw node IDs
        if show_node_ids:
            for i, (x, y) in enumerate(points):
                ax.text(x, y, str(i), fontsize=6, color="red", alpha=0.5)

        # Draw 1D boundary lines (dim=1)
        if show_boundaries:
            for block in self.mesh.cells:
                if block.type != "line":
                    continue
                lines = block.data
                line_tags = cell_data.get("line")
                for i, edge in enumerate(lines):
                    x, y = zip(*points[edge])
                    ax.plot(x, y, color="black", linewidth=1.2)
                    if line_tags is not None:
                        tag = line_tags[i]
                        name = tag_to_name.get(tag, f"tag_{tag}")
                        cx, cy = np.mean(points[edge], axis=0)
                        ax.text(cx, cy, name, fontsize=7, color="darkgreen")

        # Construct legend from named groups that actually appear
        if legend and color_by_physical_group:
            named_tags = [
                (tag, tag_to_name[tag]) for tag in grouped_cells.keys() if tag in tag_to_name
            ]

            # Sort grain_N first, then others
            def sort_key(item):
                name = item[1]
                if name.startswith("grain_"):
                    return int(name.split("_")[-1])
                return name

            named_tags = sorted(named_tags, key=sort_key)

            handles = [
                plt.Rectangle((0, 0), 1, 1, color=color_map[tag])
                for tag, _ in named_tags
            ]
            labels = [name for _, name in named_tags]

            ax.legend(
                handles,
                labels,
                loc="lower center",
                bbox_to_anchor=(0.5, -0.12),
                ncol=6,
                fontsize=7,
                handlelength=1.2,
                columnspacing=1.2,
                frameon=False
            )

        ax.set_aspect("equal")
        ax.set_title(f"Mesh: {self.msh_path.name}", pad=20)
        ax.axis("off")

        if save_path:
            fig = ax.get_figure()
            fig.savefig(save_path, bbox_inches="tight", dpi=300)

        return ax
